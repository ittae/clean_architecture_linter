{
  "master": {
    "tasks": [
      {
        "id": "11",
        "title": "유틸리티 클래스 사용량 분석 및 중복 기능 매핑",
        "description": "CleanArchitectureUtils와 RuleUtils 간의 중복 기능을 식별하고 사용량을 분석하여 통합 계획을 수립합니다.",
        "details": "모든 규칙 파일을 스캔하여 CleanArchitectureUtils와 RuleUtils의 사용 패턴을 분석합니다. 중복 기능 매핑: isDomainLayerFile() vs isDomainFile(), isDataLayerFile() vs isDataFile(), isPresentationLayerFile() vs isPresentationFile(), isRepositoryInterface() vs isRepositoryInterfaceClass() 등. 13개 규칙 파일에서의 사용량을 정량화하고 동작 차이점을 문서화합니다. analyzer 패키지의 AST 방문자 패턴을 활용하여 메서드 호출을 추적합니다.",
        "testStrategy": "유틸리티 메서드 사용량 통계를 생성하고, 중복 기능의 동작 일치성을 검증하는 테스트를 작성합니다. 모든 규칙 파일에서 동일한 결과를 보장하는 회귀 테스트를 준비합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "CleanArchitectureUtils와 RuleUtils의 전체 메서드 인벤토리 작성",
            "description": "두 유틸리티 클래스의 모든 public 메서드를 목록화하고 각 메서드의 시그니처, 파라미터, 반환 타입을 문서화합니다.",
            "dependencies": [],
            "details": "lib/src/clean_architecture_linter_base.dart의 CleanArchitectureUtils 클래스와 lib/src/utils/rule_utils.dart의 RuleUtils 클래스를 분석합니다. 각 메서드의 정확한 시그니처와 AST 노드 타입(FileUnit, ClassDeclaration, MethodDeclaration 등)을 포함한 상세 스펙을 작성합니다. 메서드별 주요 기능과 사용 목적을 간단히 설명하는 매핑 테이블을 생성합니다.\n<info added on 2025-10-05T07:13:39.956Z>\n메서드 인벤토리 작성이 완료되어 .taskmaster/docs/utility_methods_inventory.md 파일에 CleanArchitectureUtils 6개 메서드와 RuleUtils 27개 메서드가 카테고리별로 분류되어 문서화되었습니다. 각 메서드의 시그니처, 파라미터, 반환 타입이 상세히 기록되었으며, 주요 기능별 매핑 테이블이 생성되었습니다. 다음 단계인 중복 기능 식별을 위한 기초 자료가 준비되었습니다.\n</info added on 2025-10-05T07:13:39.956Z>",
            "status": "done",
            "testStrategy": "두 클래스의 모든 public 메서드가 문서화되었는지 확인하고, 메서드 시그니처가 정확하게 캡처되었는지 검증합니다.",
            "updatedAt": "2025-10-05T07:13:53.133Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "중복 기능 식별 및 동작 차이점 분석",
            "description": "CleanArchitectureUtils와 RuleUtils 간의 중복 메서드를 매핑하고 각 쌍의 구현 차이점을 상세히 분석합니다.",
            "dependencies": [
              "11.1"
            ],
            "details": "중복 메서드 쌍 매핑: isDomainLayerFile() vs isDomainFile(), isDataLayerFile() vs isDataFile(), isPresentationLayerFile() vs isPresentationFile(), isRepositoryInterface() vs isRepositoryInterfaceClass(), extractFeatureName() 중복 등. 각 쌍에 대해 정규 표현식 패턴, null 처리 방식, 파일 제외 로직(test/, generated/ 등), 반환값 차이를 비교합니다. 동작이 완전히 동일한 메서드와 미묘한 차이가 있는 메서드를 구분하여 리스트업합니다.",
            "status": "done",
            "testStrategy": "중복 메서드 쌍에 대해 동일한 입력으로 테스트하여 출력 차이를 검증하고, 차이점이 있는 경우 그 이유를 문서화합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-05T07:23:19.675Z"
          },
          {
            "id": 3,
            "title": "13개 규칙 파일에서의 유틸리티 사용량 정량 분석",
            "description": "모든 lint 규칙 파일을 스캔하여 각 유틸리티 메서드의 사용 빈도와 패턴을 정량적으로 분석합니다.",
            "dependencies": [
              "11.1"
            ],
            "details": "lib/src/rules/ 디렉토리의 domain_rules, data_rules, presentation_rules 폴더 내 13개 규칙 파일을 대상으로 분석합니다. Grep과 AST 방문자 패턴을 활용하여 CleanArchitectureUtils.* 및 RuleUtils.* 메서드 호출을 추적합니다. 각 메서드의 사용 횟수, 사용하는 규칙 파일 목록, 주요 사용 컨텍스트를 집계합니다. 가장 많이 사용되는 메서드 TOP 10과 전혀 사용되지 않는 메서드를 식별합니다.\n<info added on 2025-10-05T07:31:12.932Z>\n완료 분석 결과: 24개 규칙 파일에서 총 38개 유틸리티 메서드 호출 발견. CleanArchitectureUtils 13회(34.2%), RuleUtils 25회(65.8%) 사용. 최고 사용빈도 메서드는 isDomainLayerFile 11회(28.9%). 13개 파일 중 54.2%가 유틸리티 메서드를 활용하며, 나머지 45.8%는 직접 구현 방식 사용. 중복 기능 5개(isDomainLayerFile/isDomainFile 등) 확인됨. 통합 후 38개 호출이 19개의 새로운 통합 메서드로 정리 가능하며, 코드 중복 감소와 일관성 향상 기대됨.\n</info added on 2025-10-05T07:31:12.932Z>",
            "status": "done",
            "testStrategy": "자동화된 스크립트로 메서드 사용량을 카운트하고, 수동 검증을 통해 정확도를 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-05T07:31:40.976Z"
          },
          {
            "id": 4,
            "title": "유틸리티 통합 영향도 분석 보고서 작성",
            "description": "통합 시 영향을 받을 규칙 파일들을 식별하고 리팩토링 복잡도를 평가하는 상세 보고서를 작성합니다.",
            "dependencies": [
              "11.2",
              "11.3"
            ],
            "details": "각 규칙 파일별로 사용 중인 유틸리티 메서드 목록과 통합 후 변경 필요 사항을 매핑합니다. 높은 영향도(5개 이상 메서드 사용), 중간 영향도(2-4개), 낮은 영향도(1개 이하)로 규칙을 분류합니다. 통합 시 하위 호환성 유지 방안(@Deprecated 사용, 래퍼 메서드 등)을 검토합니다. 예상 리팩토링 작업량을 라인 수와 파일 수로 정량화합니다.\n<info added on 2025-10-05T07:37:35.731Z>\n**통합 영향도 분석 완료 보고서**: 24개 규칙 파일 중 13개 파일이 영향을 받으며(54.2% 영향도), 실제 코드 변경 작업은 4시간, 전체 프로젝트 완료까지 3주 소요 예상. 높은 영향도 1개 파일(datasource_abstraction_rule.dart), 중간 영향도 9개 파일, 낮은 영향도 3개 파일로 분류 완료. 하위 호환성 전략으로 @Deprecated 어노테이션과 점진적 마이그레이션 방식 채택. 5단계 마이그레이션 로드맵(준비→API설계→파일마이그레이션→정리→테스트) 수립하고, 기술적/프로젝트 리스크 완화 전략과 롤백 계획 포함한 포괄적 실행 계획 완성. 정량적 지표 기반 ROI 분석 결과 통합 실행을 강력히 권장함.\n</info added on 2025-10-05T07:37:35.731Z>",
            "status": "done",
            "testStrategy": "영향도 분석 결과를 실제 코드 변경 시뮬레이션으로 검증하고, 모든 규칙이 올바르게 분류되었는지 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-05T07:37:49.601Z"
          },
          {
            "id": 5,
            "title": "통합 유틸리티 마이그레이션 계획 수립",
            "description": "CleanArchitectureUtils로의 단계적 통합을 위한 구체적인 마이그레이션 로드맵과 작업 우선순위를 정의합니다.",
            "dependencies": [
              "11.4"
            ],
            "details": "Phase 1: 완전히 동일한 동작의 중복 메서드 통합(즉시 병합 가능). Phase 2: 미묘한 차이가 있는 메서드의 최적 구현 선택 및 통합. Phase 3: 고유 메서드들의 클래스 재배치 및 네이밍 일관성 개선. Phase 4: 13개 규칙 파일의 import 문 및 메서드 호출 업데이트. 각 단계별 예상 소요 시간과 리스크 요소를 명시합니다. 회귀 테스트 전략과 단계별 검증 방법을 포함합니다.\n<info added on 2025-10-05T07:44:53.793Z>\n구체적인 마이그레이션 계획 문서(.taskmaster/docs/migration_plan.md)를 성공적으로 작성하여 통합 유틸리티 마이그레이션 계획이 완료되었습니다.\n\n**작업 완료 요약**:\n\n📋 **4단계 마이그레이션 전략 수립**\n- Phase 1: 완전 중복 메서드 통합 (건너뛰기 - 완전히 동일한 메서드 없음)\n- Phase 2: 미묘한 차이 메서드 통합 (7시간, 레이어 감지 + Repository 검증)\n- Phase 3: 고유 메서드 이동 및 네이밍 일관성 (11.5시간, 25개 메서드)\n- Phase 4: 13개 규칙 파일 업데이트 (3.75시간)\n\n🔄 **주요 통합 전략 확정**\n- 레이어 파일 감지: 두 가지 장점 결합 (확장 경로 패턴 + 파일 제외 로직)\n- Repository 검증: 두 메서드 모두 유지 (서로 다른 용도)\n- 네이밍 컨벤션: 일관된 명명 규칙 적용\n- 하위 호환성: @Deprecated 어노테이션 활용\n\n📊 **세부 분석 결과**\n- 전체 작업량: 22.25시간 (~3일)\n- 영향받는 파일: 13개/24개 (54.2%)\n- 통합/이동 메서드: 29개\n- 삭제 예정 메서드: 9개 (미사용)\n- 변경 라인 수: ~250줄\n\n🎯 **다음 단계 정의**\n- Task 12: 통합 유틸리티 클래스 설계 및 API 정의\n- 3주 내 완료 가능한 실행 계획\n- 높은 ROI 예상 (중복 제거 + 일관성 향상)\n\n이제 Task 12에서 구체적인 API 설계와 구현을 시작할 수 있는 완전한 마이그레이션 로드맵이 준비되었습니다.\n</info added on 2025-10-05T07:44:53.793Z>",
            "status": "done",
            "testStrategy": "각 마이그레이션 단계마다 기존 테스트가 모두 통과하는지 확인하고, 통합 전후 동작 일치성을 검증하는 회귀 테스트를 실행합니다.",
            "parentId": "undefined",
            "updatedAt": "2025-10-05T07:45:01.423Z"
          }
        ],
        "updatedAt": "2025-10-05T07:45:01.423Z"
      },
      {
        "id": "12",
        "title": "통합 유틸리티 클래스 설계 및 API 정의",
        "description": "단일 통합 유틸리티 클래스 CleanArchitectureUtils의 새로운 API를 설계하고 일관된 네이밍 컨벤션을 정의합니다.",
        "details": "새로운 통합 API 설계: 파일 경로 분석 (isDomainFile, isDataFile, isPresentationFile, isDataSourceFile, isRepositoryFile, isUseCaseFile), 클래스 분석 (isUseCaseClass, isDataSourceClass, isRepositoryClass, isRepositoryInterfaceClass, isRepositoryImplementationClass), 타입 분석 (isResultType, isVoidType, implementsException), Exception 패턴 (isDataException, isDomainException), AST 탐색 (findParentClass, isPrivateMethod, isRethrow), Feature 유틸리티 (extractFeatureName). 일관된 네이밍 컨벤션 적용: {layer}File(), is{Type}File(), is{Type}Class(), is{Type}Type() 패턴을 사용합니다.",
        "testStrategy": "새로운 API에 대한 포괄적인 단위 테스트를 작성하고, 기존 RuleUtils와 CleanArchitectureUtils의 모든 테스트 케이스를 커버하도록 합니다. 경계 조건과 예외 상황을 테스트합니다.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T07:50:53.199Z"
      },
      {
        "id": "13",
        "title": "통합 유틸리티 클래스 구현",
        "description": "설계된 API를 바탕으로 새로운 통합 CleanArchitectureUtils 클래스를 구현하고 기존 기능의 최선 구현을 병합합니다.",
        "details": "lib/src/clean_architecture_linter_base.dart에 새로운 통합 메서드들을 추가합니다. 기존 CleanArchitectureUtils의 파일 제외 로직과 RuleUtils의 정확한 패턴 매칭을 결합하여 최적화된 구현을 만듭니다. 하위 호환성을 위해 기존 메서드에 @Deprecated 어노테이션을 추가하고 새 메서드로 리다이렉션합니다. 타입 안전성과 성능을 고려하여 nullable 파라미터 처리와 정규 표현식 최적화를 구현합니다.",
        "testStrategy": "통합된 유틸리티 클래스의 모든 메서드에 대한 단위 테스트를 작성하고, 기존 CleanArchitectureUtils와 RuleUtils의 100% 호환성을 검증합니다. 성능 벤치마크 테스트를 추가합니다.",
        "priority": "high",
        "dependencies": [
          "12"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T08:01:28.837Z"
      },
      {
        "id": "14",
        "title": "규칙 파일들을 통합 유틸리티로 마이그레이션",
        "description": "13개 규칙 파일을 새로운 통합 CleanArchitectureUtils를 사용하도록 마이그레이션하고 RuleUtils 의존성을 제거합니다.",
        "details": "lib/src/rules/ 하위의 모든 규칙 파일에서 RuleUtils import를 CleanArchitectureUtils로 변경합니다. 메서드 호출을 새로운 API에 맞게 업데이트: RuleUtils.isDomainFile() → CleanArchitectureUtils.isDomainFile(), RuleUtils.isRepositoryInterfaceClass() → CleanArchitectureUtils.isRepositoryInterfaceClass() 등. lib/src/utils/rule_utils.dart 파일을 삭제합니다. import 문을 정리하고 사용하지 않는 import를 제거합니다.",
        "testStrategy": "마이그레이션 후 모든 기존 테스트가 통과하는지 확인하고, 규칙 동작의 일관성을 검증합니다. 예제 프로젝트에서 lint 규칙을 실행하여 동일한 결과를 얻는지 테스트합니다.",
        "priority": "high",
        "dependencies": [
          "13"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T08:06:09.757Z"
      },
      {
        "id": "15",
        "title": "규칙 구조 표준화 - cross_layer 디렉토리 생성",
        "description": "최상위 규칙들을 cross_layer 디렉토리로 재구성하여 일관된 규칙 구조를 확립합니다.",
        "details": "lib/src/rules/cross_layer/ 디렉토리를 생성하고 다음 4개 규칙을 이동합니다: boundary_crossing_rule.dart, circular_dependency_rule.dart, layer_dependency_rule.dart, test_coverage_rule.dart. 이 규칙들은 여러 레이어에 걸친 검증을 수행하므로 cross_layer 카테고리에 적합합니다. lib/clean_architecture_linter.dart의 import 경로를 업데이트합니다. 각 카테고리별로 README.md 파일을 생성하여 규칙의 목적과 사용법을 설명합니다.",
        "testStrategy": "플러그인이 모든 규칙을 올바르게 로드하는지 확인하고, import 해결이 정상적으로 작동하는지 테스트합니다. 예제 프로젝트에서 모든 24개 규칙이 활성화되는지 검증합니다.",
        "priority": "medium",
        "dependencies": [
          "14"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T08:16:28.429Z"
      },
      {
        "id": "16",
        "title": "공통 패턴 추상화 설계 및 구현",
        "description": "규칙들 간의 공통 패턴을 식별하고 재사용 가능한 mixin과 base visitor를 구현합니다.",
        "details": "ExceptionValidationMixin을 생성하여 Exception 처리 검증 로직을 공유합니다. ReturnTypeValidationMixin을 만들어 반환 타입 검증을 표준화합니다. RepositoryRuleVisitor base class를 구현하여 Repository 관련 규칙의 공통 탐색 로직을 제공합니다. AST 탐색 패턴, 에러 리포팅 패턴, 타입 체크 패턴을 추상화합니다. 각 mixin과 base class는 lib/src/mixins/ 디렉토리에 배치합니다.",
        "testStrategy": "mixin과 base visitor의 기능을 독립적으로 테스트하고, 이를 사용하는 규칙들이 정상적으로 작동하는지 검증합니다. 코드 중복이 실제로 감소했는지 측정합니다.",
        "priority": "medium",
        "dependencies": [
          "15"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T08:24:36.202Z"
      },
      {
        "id": "17",
        "title": "기존 규칙들을 공통 패턴으로 리팩토링",
        "description": "구현된 mixin과 base visitor를 사용하여 기존 규칙들을 리팩토링하고 코드 중복을 제거합니다.",
        "details": "Exception 관련 규칙들(ExceptionNamingConventionRule, DataSourceExceptionTypesRule, PresentationNoDataExceptionsRule)을 ExceptionValidationMixin을 사용하도록 리팩토링합니다. Repository 관련 규칙들을 RepositoryRuleVisitor를 상속하도록 변경합니다. 반환 타입 검증이 필요한 규칙들에 ReturnTypeValidationMixin을 적용합니다. 각 규칙 파일의 코드 길이를 측정하여 리팩토링 효과를 정량화합니다.",
        "testStrategy": "리팩토링된 각 규칙이 기존과 동일한 동작을 수행하는지 검증하고, 새로운 공통 패턴이 올바르게 적용되었는지 테스트합니다. 성능이 저하되지 않았는지 확인합니다.",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T08:53:36.832Z"
      },
      {
        "id": "18",
        "title": "테스트 커버리지 개선 및 품질 검증",
        "description": "테스트 커버리지를 90% 이상으로 향상시키고 모든 Dart lint 규칙을 통과하도록 코드 품질을 개선합니다.",
        "details": "dart pub test --coverage 명령으로 현재 테스트 커버리지를 측정합니다. 커버리지가 부족한 유틸리티 함수와 규칙들에 대한 추가 테스트를 작성합니다. 통합 테스트를 추가하여 여러 규칙이 함께 작동하는 시나리오를 검증합니다. dart analyze 명령으로 모든 정적 분석 경고를 해결합니다. lints: ^6.0.0 패키지의 모든 권장사항을 적용합니다. example 프로젝트에서 성능 벤치마크를 실행하여 린트 실행 시간을 측정합니다.",
        "testStrategy": "커버리지 리포트를 생성하고 90% 이상 달성을 확인합니다. 모든 CI/CD 품질 게이트를 통과하는지 검증하고, 성능 저하가 없는지 벤치마크 결과를 비교합니다.",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T13:29:28.101Z"
      },
      {
        "id": "19",
        "title": "문서화 강화 - API 문서와 아키텍처 가이드",
        "description": "리팩토링된 구조에 맞게 모든 문서를 업데이트하고 포괄적인 API 문서화를 완성합니다.",
        "details": "CLAUDE.md를 새로운 규칙 구조와 통합 유틸리티 클래스로 업데이트합니다. README.md에 새로운 디렉토리 구조와 공통 패턴 사용법을 반영합니다. ARCHITECTURE.md 문서를 생성하여 설계 결정사항과 패턴 사용 가이드를 설명합니다. 모든 public API에 dartdoc 주석을 추가하고 사용 예제를 포함합니다. docs/ 디렉토리에 규칙 개발 가이드와 마이그레이션 가이드를 추가합니다. CONTRIBUTING.md를 작성하여 새로운 규칙 개발 프로세스를 안내합니다.",
        "testStrategy": "문서의 모든 코드 예제가 실제로 작동하는지 검증하고, 새로운 개발자가 가이드를 따라 규칙을 추가할 수 있는지 테스트합니다.",
        "priority": "medium",
        "dependencies": [
          "18"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T13:39:34.029Z"
      },
      {
        "id": "20",
        "title": "최종 검증 및 버전 릴리스 준비",
        "description": "모든 리팩토링 변경사항을 검증하고 v2.0.0 릴리스를 위한 준비를 완료합니다.",
        "details": "모든 24개 규칙이 정상 작동하는지 종합 검증을 수행합니다. 예제 프로젝트와 실제 Flutter 프로젝트에서 lint 규칙을 테스트합니다. 성능 벤치마크 결과를 리팩토링 전과 비교하여 개선 효과를 측정합니다. pubspec.yaml의 버전을 2.0.0으로 업데이트하고 CHANGELOG.md를 작성합니다. dart pub publish --dry-run 명령으로 패키지 발행 준비 상태를 확인합니다. 호환성 파괴 변경사항과 마이그레이션 가이드를 최종 검토합니다.",
        "testStrategy": "전체 테스트 스위트를 실행하여 100% 통과를 확인하고, 다양한 Flutter 프로젝트에서 린터를 테스트하여 실제 사용 시나리오를 검증합니다. 패키지 크기 감소와 실행 성능 향상을 정량적으로 측정합니다.",
        "priority": "high",
        "dependencies": [
          "19"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-05T14:16:48.044Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-05T14:16:48.045Z",
      "taskCount": 10,
      "completedCount": 10,
      "tags": [
        "master"
      ]
    }
  }
}