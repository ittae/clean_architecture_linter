# Clean Architecture Linter - 코드 리팩토링 & 품질 개선 PRD

## 요약

이 PRD는 Clean Architecture Linter 프로젝트의 코드 중복 제거, 유지보수성 개선, 아키텍처 일관성 확보, 코드 품질 향상을 위한 종합적인 리팩토링 계획을 설명합니다. 리팩토링은 위험을 최소화하면서 개선 효과를 극대화하기 위해 단계별로 진행됩니다.

## 프로젝트 현황

**현재 상태**: Clean Architecture Linter는 domain, data, presentation 레이어에 걸쳐 13개의 lint 규칙을 가진 기능적인 Dart 패키지입니다. 그러나 분석 결과 다음과 같은 문제점이 발견되었습니다:
- CleanArchitectureUtils와 RuleUtils에 중복된 유틸리티 함수들
- 일관성 없는 규칙 구조 (4개의 최상위 규칙 vs 13개의 카테고리별 규칙)
- 중복되는 파일 경로 감지 로직
- 더 나은 코드 재사용과 유지보수성의 여지

**목표**: 기존 기능과 테스트 커버리지를 모두 유지하면서 더욱 유지보수 가능하고, 일관적이며, 효율적인 코드베이스를 만듭니다.

## 문제 정의

### 1. 코드 중복 문제

**문제점**: 두 개의 유틸리티 클래스(CleanArchitectureUtils와 RuleUtils)가 중복된 기능을 제공합니다:

- **파일 경로 감지**:
  - CleanArchitectureUtils: isDomainLayerFile(), isDataLayerFile(), isPresentationLayerFile()
  - RuleUtils: isDomainFile(), isDataFile(), isPresentationFile()

- **경로 정규화**:
  - 두 클래스 모두 경로 정규화 로직 구현
  - 레이어 감지에서 약간 다른 패턴 사용

- **Repository 감지**:
  - CleanArchitectureUtils: isRepositoryInterface(), isRepositoryInterfaceMethod()
  - RuleUtils: isRepositoryClass(), isRepositoryInterfaceClass(), isRepositoryImplementationClass()

**영향**:
- 유지보수 부담 (변경사항을 동기화해야 함)
- 동작 불일치 위험
- 개발자의 인지 부하 증가
- 패키지 크기 증가

### 2. 아키텍처 불일치

**문제점**: 규칙들이 두 가지 다른 패턴으로 구성되어 있습니다:

**최상위 규칙** (lib/src/rules/ 에 위치):
- boundary_crossing_rule.dart
- circular_dependency_rule.dart
- layer_dependency_rule.dart
- test_coverage_rule.dart

**카테고리별 규칙** (lib/src/rules/{category}/ 에 위치):
- domain_rules/ (7개 규칙)
- data_rules/ (7개 규칙)
- presentation_rules/ (6개 규칙)

**영향**:
- 불명확한 구조화 원칙
- 특정 규칙을 찾기 어려움
- 일관성 없는 import 패턴

### 3. 네이밍 불일치

**문제점**: 유사한 기능에 대해 일관성 없는 네이밍 패턴:

- 파일 감지: `isDomainLayerFile()` vs `isDomainFile()`
- Repository 체크: `isRepositoryInterface()` vs `isRepositoryInterfaceClass()`
- UseCase 체크: `isUseCaseClass()` vs `isUseCaseFile()`

**영향**:
- 올바른 메서드를 선택할 때 인지 부하
- 잘못된 유틸리티 사용으로 인한 버그 가능성

### 4. 추상화 부족

**문제점**: 공통 패턴이 공유 추상화 없이 여러 규칙에서 반복됨:

- Exception 감지 로직
- Type annotation 체크
- AST 탐색 패턴
- 에러 리포팅 패턴

**영향**:
- 장황한 규칙 구현
- 일관성 보장의 어려움
- 높은 테스트 부담

## 성공 기준

### 정량적 지표

1. **코드 중복**: 중복 코드 80% 이상 감소
2. **유틸리티 통합**: 단일 통합 유틸리티 클래스
3. **규칙 구조**: 100% 규칙이 일관된 카테고리화 따름
4. **테스트 커버리지**: 현재 테스트 커버리지 유지 또는 개선 (>90%)
5. **패키지 크기**: 컴파일된 패키지 크기 15% 이상 감소
6. **문서화**: 모든 public API가 예제와 함께 문서화됨

### 정성적 지표

1. **유지보수성**: 새 규칙을 50줄 미만의 코드로 추가 가능
2. **일관성**: 모든 유사 기능이 동일한 네이밍 패턴 사용
3. **발견성**: 개발자가 30초 내에 올바른 유틸리티를 찾을 수 있음
4. **신뢰성**: 모든 기존 lint 규칙이 동일한 결과 생성

## 제안 솔루션

### Phase 1: 유틸리티 통합

**목표**: CleanArchitectureUtils와 RuleUtils를 단일 통합 유틸리티 클래스로 병합

**작업**:

1. **유틸리티 사용 분석**
   - 모든 규칙 파일을 감사하여 어떤 유틸리티가 사용되는지 파악
   - 중복 기능 식별
   - 동작 차이점 문서화

2. **통합 유틸리티 구조 설계**
   ```dart
   class CleanArchitectureUtils {
     // 파일 경로 분석
     static bool shouldExcludeFile(String filePath)
     static bool isDomainFile(String filePath)
     static bool isDataFile(String filePath)
     static bool isPresentationFile(String filePath)
     static bool isDataSourceFile(String filePath)
     static bool isRepositoryFile(String filePath)
     static bool isUseCaseFile(String filePath)

     // 클래스 분석
     static bool isUseCaseClass(String className)
     static bool isDataSourceClass(String className)
     static bool isRepositoryClass(String className)
     static bool isRepositoryInterfaceClass(String className)
     static bool isRepositoryImplementationClass(String className)

     // 타입 분석
     static bool isResultType(TypeAnnotation? returnType)
     static bool isVoidType(TypeAnnotation? returnType)
     static bool implementsException(ClassDeclaration node)

     // Exception 패턴
     static bool isDataException(String typeName)
     static bool isDomainException(String typeName)

     // AST 탐색
     static ClassDeclaration? findParentClass(AstNode? node)
     static bool isPrivateMethod(MethodDeclaration method)
     static bool isRethrow(ThrowExpression node)

     // Feature & 경로 유틸리티
     static String? extractFeatureName(String filePath)
   }
   ```

3. **통합 유틸리티 구현**
   - 두 클래스의 최선 구현을 병합
   - 전환 기간 동안 하위 호환성 보장
   - 포괄적인 단위 테스트 추가

4. **규칙들을 통합 유틸리티로 마이그레이션**
   - 모든 규칙 파일을 새로운 통합 유틸리티 사용하도록 업데이트
   - RuleUtils 클래스 제거
   - base 파일의 CleanArchitectureUtils 업데이트

5. **검증**
   - 모든 테스트 실행하여 동일한 동작 보장
   - 예제 프로젝트로 테스트
   - 호환성 파괴 변경 없음 확인

**완료 기준**:
- ✅ 모든 기능을 가진 단일 유틸리티 클래스
- ✅ 모든 규칙 마이그레이션 완료 및 테스트 통과
- ✅ RuleUtils.dart 삭제됨
- ✅ 100% 하위 호환 동작
- ✅ 포괄적인 문서화 완료

### Phase 2: 규칙 구조 표준화

**목표**: 일관된 규칙 구조 패턴 확립 및 적용

**작업**:

1. **구조화 원칙 정의**
   - 카테고리화 기준 문서화
   - 규칙이 최상위 vs 카테고리별로 위치해야 하는 경우 정의

   **제안 구조**:
   ```
   lib/src/rules/
   ├── cross_layer/          # 여러 레이어에 걸친 규칙
   │   ├── boundary_crossing_rule.dart
   │   ├── circular_dependency_rule.dart
   │   ├── layer_dependency_rule.dart
   │   └── test_coverage_rule.dart
   ├── domain_rules/         # Domain 레이어 전용 규칙
   ├── data_rules/           # Data 레이어 전용 규칙
   └── presentation_rules/   # Presentation 레이어 전용 규칙
   ```

2. **최상위 규칙 재구성**
   - cross_layer/ 디렉토리 생성
   - 4개 최상위 규칙을 cross_layer/로 이동
   - 메인 플러그인 파일의 import 업데이트

3. **문서화 업데이트**
   - CLAUDE.md를 새로운 구조로 업데이트
   - 각 규칙 카테고리에 README 추가
   - 각 카테고리에 규칙을 추가하는 시점 문서화

4. **검증**
   - 플러그인이 모든 규칙을 여전히 발견하는지 확인
   - import 해결 테스트
   - 예제 프로젝트 참조 업데이트

**완료 기준**:
- ✅ 모든 규칙이 명확한 카테고리로 구성됨
- ✅ 문서가 구조화 원칙을 설명함
- ✅ 고아 또는 중복 규칙 없음
- ✅ 모든 테스트 통과

### Phase 3: 네이밍 일관성 개선

**목표**: 모든 유틸리티와 규칙에 대해 네이밍 컨벤션 표준화

**작업**:

1. **네이밍 표준 정의**
   ```dart
   // 파일 경로 체크 - {layer}File()
   static bool isDomainFile(String filePath)
   static bool isDataFile(String filePath)
   static bool isPresentationFile(String filePath)

   // 특정 파일 타입 체크 - is{Type}File()
   static bool isDataSourceFile(String filePath)
   static bool isRepositoryFile(String filePath)
   static bool isUseCaseFile(String filePath)

   // 클래스 이름 체크 - is{Type}Class()
   static bool isUseCaseClass(String className)
   static bool isRepositoryClass(String className)
   static bool isDataSourceClass(String className)

   // 타입 체크 - is{Type}Type()
   static bool isResultType(TypeAnnotation? type)
   static bool isVoidType(TypeAnnotation? type)
   static bool isExceptionType(ClassDeclaration node)
   ```

2. **네이밍 변경 구현**
   - 일관성 없는 메서드 이름 변경
   - 이전 이름에 @Deprecated 어노테이션 추가
   - 모든 내부 사용 업데이트

3. **문서화 업데이트**
   - CLAUDE.md에 네이밍 컨벤션 문서화
   - 각 패턴에 대한 예제 추가
   - 마이그레이션 가이드 작성

**완료 기준**:
- ✅ 모든 유틸리티가 일관된 네이밍 따름
- ✅ Deprecated 메서드가 마이그레이션 경로와 함께 표시됨
- ✅ 문서가 컨벤션과 함께 업데이트됨
- ✅ 모든 규칙이 새 네이밍 사용

### Phase 4: 공유 추상화 & 패턴

**목표**: 공통 패턴을 재사용 가능한 추상화로 추출

**작업**:

1. **공통 패턴 식별**
   - 규칙들 전반의 Exception 처리
   - AST 탐색 패턴
   - 에러 리포팅 패턴
   - 반환 타입 검증

2. **패턴 추상화 생성**
   ```dart
   /// Exception 처리를 검증하는 규칙을 위한 Mixin
   mixin ExceptionValidationMixin {
     void validateExceptionType(
       ThrowExpression node,
       ErrorReporter reporter,
       bool Function(String) isValidException,
     );
   }

   /// 반환 타입을 검증하는 규칙을 위한 Mixin
   mixin ReturnTypeValidationMixin {
     void validateReturnType(
       MethodDeclaration method,
       ErrorReporter reporter,
       bool Function(TypeAnnotation?) isValidReturnType,
     );
   }

   /// Repository 규칙을 위한 Base visitor
   class RepositoryRuleVisitor extends SimpleAstVisitor<void> {
     // 공통 repository 검증 로직
   }
   ```

3. **패턴을 사용하도록 규칙 리팩토링**
   - mixin과 base visitor를 사용하도록 규칙 업데이트
   - 개별 규칙 파일의 코드 감소
   - 일관성 개선

4. **문서화**
   - 사용 가능한 패턴 문서화
   - 사용 예제 제공
   - 규칙 개발 가이드 작성

**완료 기준**:
- ✅ 공통 패턴이 재사용 가능한 컴포넌트로 추출됨
- ✅ 패턴을 사용하여 규칙 단순화됨
- ✅ 패턴 문서화 완료
- ✅ 개발자 가이드 업데이트됨

### Phase 5: 테스트 & 품질 개선

**목표**: 테스트 커버리지 및 코드 품질 향상

**작업**:

1. **테스트 커버리지 감사**
   - 테스트 커버리지 갭 식별
   - 유틸리티 함수에 대한 테스트 추가
   - 규칙 조합에 대한 통합 테스트 추가

2. **테스트 구성 개선**
   - 테스트 파일에서 규칙 구조 반영
   - 공유 테스트 유틸리티 생성
   - 테스트 문서화 추가

3. **품질 체크 추가**
   - 모든 권장 Dart lint 활성화
   - 모든 lint 경고 수정
   - CI/CD 품질 게이트 추가

4. **성능 검증**
   - 규칙 실행 시간 벤치마크
   - 성능 병목 식별
   - 느린 작업 최적화

**완료 기준**:
- ✅ 테스트 커버리지 >90%
- ✅ 모든 lint 통과
- ✅ 성능 벤치마크 문서화됨
- ✅ CI/CD 파이프라인 업데이트됨

### Phase 6: 문서화 강화

**목표**: 유지관리자와 사용자를 위한 포괄적인 문서화

**작업**:

1. **프로젝트 문서 업데이트**
   - CLAUDE.md를 리팩토링 변경사항으로 업데이트
   - README.md를 새 구조로 업데이트
   - CONTRIBUTING.md 가이드 추가

2. **API 문서화**
   - 모든 public API에 dartdoc 주석 추가
   - 사용 예제 포함
   - Edge case 문서화

3. **아키텍처 문서화**
   - ARCHITECTURE.md 생성
   - 설계 결정 문서화
   - 규칙 개발 가이드 추가

4. **마이그레이션 가이드**
   - 모든 호환성 파괴 변경사항 문서화
   - 마이그레이션 예제 제공
   - 버전 호환성 매트릭스 생성

**완료 기준**:
- ✅ 모든 public API 문서화됨
- ✅ 아키텍처 문서화 완료
- ✅ 마이그레이션 가이드 사용 가능
- ✅ 예제 업데이트됨

## 구현 일정

### 1-2주차: Phase 1 - 유틸리티 통합
- 1-3일: 분석 및 설계
- 4-7일: 구현 및 테스트
- 8-10일: 마이그레이션 및 검증

### 3주차: Phase 2 - 규칙 구조화
- 1-2일: 구조 정의 및 구현
- 3-4일: 규칙 재구성
- 5일: 검증 및 문서화

### 4주차: Phase 3 - 네이밍 일관성
- 1-2일: 표준 정의
- 3-4일: 변경사항 구현
- 5일: 문서화

### 5주차: Phase 4 - 공유 추상화
- 1-2일: 패턴 식별
- 3-5일: 추상화 구현

### 6주차: Phase 5 - 테스트 & 품질
- 1-3일: 테스트 커버리지
- 4-5일: 품질 개선

### 7주차: Phase 6 - 문서화
- 1-5일: 포괄적인 문서화

## 리스크 평가

### 기술적 리스크

1. **호환성 파괴 변경** (높은 영향, 중간 확률)
   - **완화책**: 광범위한 테스트, deprecation 기간, 버전 관리

2. **테스트 커버리지 갭** (중간 영향, 중간 확률)
   - **완화책**: 변경 전 감사, 리팩토링 전 커버리지 증가

3. **성능 저하** (중간 영향, 낮은 확률)
   - **완화책**: 전후 벤치마크, 성능 테스트

### 프로세스 리스크

1. **범위 확대** (중간 영향, 중간 확률)
   - **완화책**: 엄격한 phase 경계, 명확한 완료 기준

2. **일정 초과** (낮은 영향, 중간 확률)
   - **완화책**: 각 phase에 버퍼 시간, 핵심 개선 우선순위화

## 의존성

### 필수
- Dart SDK ≥3.0.0
- analyzer ^6.8.0
- custom_lint_builder ^0.6.7

### 개발
- test 패키지
- Coverage 도구

## 성공 검증

### Phase 완료 체크리스트

각 phase마다:
- [ ] 모든 완료 기준 충족
- [ ] 테스트 통과 (100%)
- [ ] 문서화 업데이트됨
- [ ] 코드 리뷰 완료
- [ ] 성능 검증됨
- [ ] 예제 프로젝트 테스트됨

### 최종 검증

- [ ] 모든 6개 phase 완료
- [ ] 기능 회귀 없음
- [ ] 테스트 커버리지 >90%
- [ ] 문서화 완료
- [ ] 성능 유지 또는 개선됨
- [ ] 패키지 크기 감소됨
- [ ] 개발자 피드백 긍정적

## 리팩토링 후 기대 효과

1. **유지보수성**: 유틸리티에 대한 단일 진실 공급원
2. **일관성**: 규칙 개발을 위한 명확한 패턴
3. **품질**: 개선된 테스트 커버리지 및 문서화
4. **성능**: 최적화된 공통 작업
5. **개발자 경험**: 빠른 온보딩, 쉬운 기여
6. **확장성**: 새 규칙을 효율적으로 추가할 수 있는 기반

## 부록 A: 파일 목록

### 현재 구조
```
lib/
├── clean_architecture_linter.dart (메인 진입점)
├── src/
│   ├── clean_architecture_linter_base.dart (CleanArchitectureUtils)
│   ├── utils/
│   │   └── rule_utils.dart (RuleUtils - 병합 예정)
│   └── rules/
│       ├── boundary_crossing_rule.dart (이동 예정)
│       ├── circular_dependency_rule.dart (이동 예정)
│       ├── layer_dependency_rule.dart (이동 예정)
│       ├── test_coverage_rule.dart (이동 예정)
│       ├── domain_rules/ (7개 규칙)
│       ├── data_rules/ (7개 규칙)
│       └── presentation_rules/ (6개 규칙)
```

### 목표 구조
```
lib/
├── clean_architecture_linter.dart
├── src/
│   ├── clean_architecture_linter_base.dart (통합 Utils)
│   └── rules/
│       ├── cross_layer/ (4개 규칙 - 이동됨)
│       ├── domain_rules/ (7개 규칙)
│       ├── data_rules/ (7개 규칙)
│       └── presentation_rules/ (6개 규칙)
```

## 부록 B: 유틸리티 통합 매핑

### 병합할 함수들

| 현재 (CleanArchitectureUtils) | 현재 (RuleUtils) | 통합 이름 |
|----------------------------------|---------------------|--------------|
| isDomainLayerFile() | isDomainFile() | isDomainFile() |
| isDataLayerFile() | isDataFile() | isDataFile() |
| isPresentationLayerFile() | isPresentationFile() | isPresentationFile() |
| isRepositoryInterface() | isRepositoryInterfaceClass() | isRepositoryInterfaceClass() |
| isRepositoryInterfaceMethod() | - | isRepositoryInterfaceMethod() |
| - | isRepositoryClass() | isRepositoryClass() |
| - | isRepositoryImplClass() | isRepositoryImplementationClass() |
| - | isUseCaseClass() | isUseCaseClass() |
| - | isDataSourceClass() | isDataSourceClass() |

### 추가할 새 함수들

- isRepositoryInterfaceFile()
- isRepositoryImplementationFile()
- isUseCaseFile()
- isDataSourceFile()
- extractFeatureName()
- isResultType()
- isVoidType()
- implementsException()
- isDataException()
- isDomainException()

## 부록 C: 호환성 파괴 변경사항

### 다음 마이너 버전에서 Deprecated
- CleanArchitectureUtils.isDomainLayerFile() → isDomainFile()
- CleanArchitectureUtils.isDataLayerFile() → isDataFile()
- CleanArchitectureUtils.isPresentationLayerFile() → isPresentationFile()
- RuleUtils 클래스 (전체 클래스 deprecated)

### 다음 메이저 버전에서 제거
- 모든 deprecated 메서드
- RuleUtils.dart 파일

## 버전 계획

- **v1.x.x** (현재): 기존 구현
- **v1.y.x** (다음 마이너): deprecation 추가, 통합 utils 사용 가능
- **v2.0.0** (다음 메이저): deprecated 코드 제거, 리팩토링 완료
